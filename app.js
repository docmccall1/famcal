const state = {
  currentDate: new Date(),
  view: "month",
  activeTab: "calendar",
  selectedPersonId: "family",
  roomId: "",
  lastUpdatedAt: 0,
  members: [],
  events: [],
  requests: [],
  todos: [],
  chores: [],
  busy: {
    husband: "",
    wife: "",
    location: "",
  },
};

const DAY_NAMES = ["Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"];
const DAY_INDEX = DAY_NAMES.reduce((acc, name, i) => {
  acc[name.toLowerCase()] = i;
  return acc;
}, {});

const SLOT_TEMPLATES = [
  { label: "Lunch", start: 12 * 60, end: 14 * 60, weight: 1 },
  { label: "Early Dinner", start: 17 * 60 + 30, end: 19 * 60 + 30, weight: 2 },
  { label: "Date Night", start: 19 * 60, end: 21 * 60, weight: 3 },
];

let syncTimer = null;

const el = {
  label: document.getElementById("currentLabel"),
  grid: document.getElementById("calendarGrid"),
  viewBtns: document.querySelectorAll(".view-btn"),
  topTabs: document.querySelectorAll(".tab-btn"),
  personTabs: document.getElementById("personTabs"),
  calendarPage: document.getElementById("calendarPage"),
  choresPage: document.getElementById("choresPage"),
  requestList: document.getElementById("requestList"),
  todoList: document.getElementById("todoList"),
  recurringList: document.getElementById("recurringList"),
  plannerOutput: document.getElementById("plannerOutput"),
  plannerPlaces: document.getElementById("plannerPlaces"),
  busyHusband: document.getElementById("busyHusband"),
  busyWife: document.getElementById("busyWife"),
  plannerLocation: document.getElementById("plannerLocation"),
  memberList: document.getElementById("memberList"),
  choreList: document.getElementById("choreList"),
  choreGenNote: document.getElementById("choreGenNote"),
  eventMember: document.getElementById("eventMember"),
  requestMember: document.getElementById("requestMember"),
  todoMember: document.getElementById("todoMember"),
  choreMember: document.getElementById("choreMember"),
  icalMember: document.getElementById("icalMember"),
};

function uid() {
  return `${Date.now()}-${Math.random().toString(36).slice(2, 8)}`;
}

function roomId() {
  return Math.random().toString(36).slice(2, 10);
}

function formatDate(date) {
  return date.toISOString().slice(0, 10);
}

function memberColor(memberName) {
  const input = (memberName || "family").toLowerCase();
  let hash = 0;
  for (let i = 0; i < input.length; i += 1) {
    hash = ((hash << 5) - hash + input.charCodeAt(i)) | 0;
  }
  const hue = Math.abs(hash) % 360;
  return `hsl(${hue} 70% 45%)`;
}

function defaultMembers() {
  return [
    { id: uid(), name: "Adult 1", role: "adult", age: 35, gender: "woman" },
    { id: uid(), name: "Adult 2", role: "adult", age: 36, gender: "man" },
    { id: uid(), name: "Kid 1", role: "child", age: 12, gender: "non-binary" },
    { id: uid(), name: "Kid 2", role: "child", age: 10, gender: "non-binary" },
    { id: uid(), name: "Kid 3", role: "child", age: 8, gender: "non-binary" },
    { id: uid(), name: "Kid 4", role: "child", age: 6, gender: "non-binary" },
  ];
}

function normalizeMember(member) {
  return {
    id: member.id || uid(),
    name: member.name || "Unnamed",
    role: member.role === "adult" ? "adult" : "child",
    age: Number(member.age) || 0,
    gender: member.gender || "non-binary",
  };
}

function normalizeEvent(ev) {
  const startDate = ev.startDate || ev.date;
  const endDate = ev.endDate || startDate;
  return {
    id: ev.id || uid(),
    title: ev.title || "Untitled",
    startDate,
    endDate: endDate && startDate && endDate < startDate ? startDate : endDate,
    start: ev.start || "",
    end: ev.end || "",
    memberId: ev.memberId || "",
    memberName: ev.memberName || ev.member || ev.person || "",
    recurring: ev.recurring || "none",
  };
}

function normalizeRequest(item) {
  return {
    id: item.id || uid(),
    text: item.text || "",
    memberId: item.memberId || "",
    memberName: item.memberName || item.member || "",
  };
}

function normalizeTodo(item) {
  return {
    id: item.id || uid(),
    text: item.text || "",
    done: !!item.done,
    mustDoDate: item.mustDoDate || formatDate(new Date()),
    memberId: item.memberId || "",
    memberName: item.memberName || item.member || "",
  };
}

function normalizeChore(chore) {
  return {
    id: chore.id || uid(),
    title: chore.title || "",
    frequency: chore.frequency || "Daily",
    done: !!chore.done,
    autogenerated: !!chore.autogenerated,
    memberId: chore.memberId || "",
    memberName: chore.memberName || chore.member || "",
  };
}

function normalizePayload(parsed) {
  const membersRaw = Array.isArray(parsed.members) ? parsed.members : [];
  const legacyChildren = Array.isArray(parsed.children)
    ? parsed.children.map((c) => ({ ...c, role: "child" }))
    : [];
  const members = (membersRaw.length ? membersRaw : legacyChildren).map(normalizeMember);

  let chores = Array.isArray(parsed.chores) ? parsed.chores.map(normalizeChore) : [];
  if (!chores.length && Array.isArray(parsed.chorePlans)) {
    const plans = parsed.chorePlans;
    chores = plans.flatMap((plan) => (Array.isArray(plan.tasks) ? plan.tasks : []).map((task) => normalizeChore({
      title: task.title,
      frequency: task.frequency,
      done: task.done,
      memberName: plan.childName,
      memberId: plan.childId,
      autogenerated: true,
    })));
  }

  return {
    members: members.length ? members : defaultMembers(),
    events: Array.isArray(parsed.events) ? parsed.events.map(normalizeEvent) : [],
    requests: Array.isArray(parsed.requests) ? parsed.requests.map(normalizeRequest) : [],
    todos: Array.isArray(parsed.todos) ? parsed.todos.map(normalizeTodo) : [],
    chores,
    selectedPersonId: typeof parsed.selectedPersonId === "string" ? parsed.selectedPersonId : "family",
    activeTab: parsed.activeTab === "chores" ? "chores" : "calendar",
    busy: parsed.busy && typeof parsed.busy === "object"
      ? {
          husband: parsed.busy.husband || "",
          wife: parsed.busy.wife || "",
          location: parsed.busy.location || "",
        }
      : { husband: "", wife: "", location: "" },
    lastUpdatedAt: Number(parsed.lastUpdatedAt) || 0,
  };
}

function findMemberById(id) {
  return state.members.find((m) => m.id === id) || null;
}

function findMemberByName(name) {
  if (!name) return null;
  const n = name.trim().toLowerCase();
  return state.members.find((m) => m.name.trim().toLowerCase() === n) || null;
}

function displayMemberName(item) {
  const byId = item.memberId ? findMemberById(item.memberId) : null;
  if (byId) return byId.name;
  if (item.memberName) return item.memberName;
  return "Unassigned";
}

function backfillMemberIds() {
  const collections = [state.events, state.requests, state.todos, state.chores];
  for (const rows of collections) {
    for (const row of rows) {
      if (!row.memberId && row.memberName) {
        const match = findMemberByName(row.memberName);
        if (match) row.memberId = match.id;
      }
      if (row.memberId && !row.memberName) {
        const m = findMemberById(row.memberId);
        row.memberName = m ? m.name : "";
      }
    }
  }
}

function itemMatchesSelected(item) {
  if (state.selectedPersonId === "family") return true;
  if (item.memberId && item.memberId === state.selectedPersonId) return true;
  const selected = findMemberById(state.selectedPersonId);
  if (!selected) return false;
  return !!item.memberName && item.memberName.trim().toLowerCase() === selected.name.trim().toLowerCase();
}

function applyLoadedState(parsed) {
  const normalized = normalizePayload(parsed || {});
  state.members = normalized.members;
  state.events = normalized.events;
  state.requests = normalized.requests;
  state.todos = normalized.todos;
  state.chores = normalized.chores;
  state.activeTab = normalized.activeTab;
  state.selectedPersonId = normalized.selectedPersonId;
  state.busy = normalized.busy;
  state.lastUpdatedAt = normalized.lastUpdatedAt;

  backfillMemberIds();
  if (state.selectedPersonId !== "family" && !findMemberById(state.selectedPersonId)) {
    state.selectedPersonId = "family";
  }
}

function serializeState() {
  return {
    members: state.members,
    events: state.events,
    requests: state.requests,
    todos: state.todos,
    chores: state.chores,
    selectedPersonId: state.selectedPersonId,
    activeTab: state.activeTab,
    busy: state.busy,
    lastUpdatedAt: state.lastUpdatedAt,
  };
}

function saveStateLocally() {
  localStorage.setItem("familyCalendarState", JSON.stringify(serializeState()));
}

function touchState() {
  state.lastUpdatedAt = Date.now();
}

async function pushRemoteState() {
  if (!state.roomId) return;
  try {
    await fetch(`/api/state?room=${encodeURIComponent(state.roomId)}`, {
      method: "PUT",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(serializeState()),
    });
  } catch (_err) {
    // Keep local state if remote is unavailable.
  }
}

async function saveState() {
  touchState();
  saveStateLocally();
  await pushRemoteState();
}

async function fetchRemoteState() {
  if (!state.roomId) return null;
  try {
    const res = await fetch(`/api/state?room=${encodeURIComponent(state.roomId)}`);
    if (!res.ok) return null;
    const payload = await res.json();
    return payload && typeof payload === "object" ? payload : null;
  } catch (_err) {
    return null;
  }
}

async function mergeRemoteIfNewer() {
  const remote = await fetchRemoteState();
  if (!remote || !remote.lastUpdatedAt) return;
  if (Number(remote.lastUpdatedAt) <= state.lastUpdatedAt) return;
  applyLoadedState(remote);
  saveStateLocally();
  render();
}

function startSyncPolling() {
  if (!state.roomId) return;
  if (syncTimer) clearInterval(syncTimer);
  syncTimer = setInterval(() => {
    mergeRemoteIfNewer();
  }, 5000);
}

async function loadState() {
  const url = new URL(window.location.href);
  const encoded = url.searchParams.get("data");
  const room = url.searchParams.get("room");
  if (room) state.roomId = room;

  if (encoded) {
    try {
      applyLoadedState(JSON.parse(decodeURIComponent(atob(encoded))));
    } catch (_err) {
      console.warn("Failed to parse shared snapshot");
    }
  }

  const raw = localStorage.getItem("familyCalendarState");
  if (raw) {
    try {
      const local = JSON.parse(raw);
      const localNorm = normalizePayload(local);
      if (localNorm.lastUpdatedAt >= state.lastUpdatedAt) applyLoadedState(local);
    } catch (_err) {
      console.warn("Failed to parse local state");
    }
  }

  if (state.roomId) {
    const remote = await fetchRemoteState();
    if (remote && Number(remote.lastUpdatedAt) > state.lastUpdatedAt) {
      applyLoadedState(remote);
    } else if (!remote && state.lastUpdatedAt > 0) {
      await pushRemoteState();
    }
  }

  if (!state.members.length) state.members = defaultMembers();
  backfillMemberIds();
  saveStateLocally();
  startSyncPolling();
}

function setActiveTab(tab, shouldSave = true) {
  state.activeTab = tab === "chores" ? "chores" : "calendar";
  el.topTabs.forEach((btn) => {
    btn.classList.toggle("active", btn.dataset.tab === state.activeTab);
  });
  el.calendarPage.classList.toggle("active", state.activeTab === "calendar");
  el.choresPage.classList.toggle("active", state.activeTab === "chores");
  if (shouldSave) saveState();
}

function setSelectedPerson(id, shouldSave = true) {
  state.selectedPersonId = id || "family";
  renderPersonTabs();
  populateMemberSelects();
  renderCalendar();
  renderRequests();
  renderTodos();
  renderRecurring();
  renderChores();
  updateChoreNote();
  if (shouldSave) saveState();
}

function visibleEvents() {
  return state.events.filter(itemMatchesSelected);
}

function visibleRequests() {
  return state.requests.filter(itemMatchesSelected);
}

function visibleTodos() {
  return state.todos.filter(itemMatchesSelected);
}

function visibleChores() {
  return state.chores.filter(itemMatchesSelected);
}

function setView(view) {
  state.view = view;
  el.viewBtns.forEach((btn) => {
    btn.classList.toggle("active", btn.dataset.view === view);
  });
  renderCalendar();
}

function shiftDate(direction) {
  const d = new Date(state.currentDate);
  if (state.view === "day") d.setDate(d.getDate() + direction);
  if (state.view === "week") d.setDate(d.getDate() + direction * 7);
  if (state.view === "month") d.setMonth(d.getMonth() + direction);
  if (state.view === "year") d.setFullYear(d.getFullYear() + direction);
  state.currentDate = d;
  renderCalendar();
}

function getWeekStart(date) {
  const d = new Date(date);
  d.setDate(d.getDate() - d.getDay());
  d.setHours(0, 0, 0, 0);
  return d;
}

function eventDateText(ev) {
  if (!ev.startDate) return "";
  if (ev.startDate === ev.endDate) {
    return new Date(`${ev.startDate}T00:00:00`).toLocaleDateString(undefined, { month: "short", day: "numeric" });
  }
  const start = new Date(`${ev.startDate}T00:00:00`).toLocaleDateString(undefined, { month: "short", day: "numeric" });
  const end = new Date(`${ev.endDate}T00:00:00`).toLocaleDateString(undefined, { month: "short", day: "numeric" });
  return `${start}-${end}`;
}

function eventsForDate(date) {
  const target = formatDate(date);
  return visibleEvents().filter((ev) => occursOnDate(ev, date, target));
}

function occursOnDate(ev, dateObj, target) {
  const startDate = ev.startDate;
  const endDate = ev.endDate || startDate;
  if (!startDate) return false;

  if (ev.recurring === "none") return target >= startDate && target <= endDate;

  const origin = new Date(`${startDate}T00:00:00`);
  if (dateObj < origin) return false;
  if (ev.recurring === "daily") return true;
  if (ev.recurring === "weekly") return origin.getDay() === dateObj.getDay();
  if (ev.recurring === "monthly") return origin.getDate() === dateObj.getDate();
  return false;
}

function dateCell(date, opts = {}) {
  const includeChores = !!opts.includeChores;
  const dStr = formatDate(date);
  const events = eventsForDate(date);
  const dateLabel = `${DAY_NAMES[date.getDay()]} ${date.getMonth() + 1}/${date.getDate()}`;
  const items = events.map((ev) => {
    const memberName = displayMemberName(ev);
    return `
      <li class="event-item" style="--member-color: ${memberColor(memberName)}">
        <div>
          <strong>${ev.start ? `${escapeHtml(ev.start)} ` : ""}${escapeHtml(ev.title)}</strong>
          <div class="event-meta">${escapeHtml(eventDateText(ev))}${ev.recurring !== "none" ? ` | ${escapeHtml(ev.recurring)}` : ""}</div>
        </div>
        <span class="member-pill" style="--member-color: ${memberColor(memberName)}">${escapeHtml(memberName)}</span>
      </li>
    `;
  }).join("");

  const choresMarkup = includeChores
    ? (() => {
      const chores = [...visibleChores()].sort((a, b) => Number(a.done) - Number(b.done));
      const rows = chores.map((chore) => `
          <li>
            <label>
              <input type="checkbox" data-toggle-chore="${chore.id}" ${chore.done ? "checked" : ""} />
              <span class="${chore.done ? "done" : ""}">${escapeHtml(chore.title)} <small>(${escapeHtml(chore.frequency)})</small></span>
            </label>
          </li>
      `).join("");
      return `
        <div class="day-chores">
          <h4>Chores</h4>
          <ul>${rows || "<li class='muted'>No chores for this view.</li>"}</ul>
        </div>
      `;
    })()
    : "";

  return `
    <article class="cell">
      <h4>${dateLabel}</h4>
      <ul>${items || "<li class='muted'>No events</li>"}</ul>
      ${choresMarkup}
      <button class="link-btn" data-action="jump" data-date="${dStr}">Add here</button>
    </article>
  `;
}

function renderCalendar() {
  const d = new Date(state.currentDate);
  const selectedLabel = state.selectedPersonId === "family" ? "Family" : (findMemberById(state.selectedPersonId)?.name || "Family");

  if (state.view === "day") {
    el.label.textContent = `${selectedLabel} | ${d.toLocaleDateString(undefined, { weekday: "long", month: "long", day: "numeric", year: "numeric" })}`;
    el.grid.className = "calendar-grid day";
    el.grid.innerHTML = dateCell(d, { includeChores: true });
    return;
  }

  if (state.view === "week") {
    const start = getWeekStart(d);
    const weekDays = Array.from({ length: 7 }, (_, i) => {
      const day = new Date(start);
      day.setDate(start.getDate() + i);
      return day;
    });
    const end = weekDays[6];
    el.label.textContent = `${selectedLabel} | ${start.toLocaleDateString(undefined, { month: "short", day: "numeric" })} - ${end.toLocaleDateString(undefined, { month: "short", day: "numeric", year: "numeric" })}`;
    el.grid.className = "calendar-grid week";
    el.grid.innerHTML = weekDays.map((day) => dateCell(day)).join("");
    return;
  }

  if (state.view === "month") {
    const monthStart = new Date(d.getFullYear(), d.getMonth(), 1);
    const start = getWeekStart(monthStart);
    const days = Array.from({ length: 42 }, (_, i) => {
      const day = new Date(start);
      day.setDate(start.getDate() + i);
      return day;
    });
    el.label.textContent = `${selectedLabel} | ${d.toLocaleDateString(undefined, { month: "long", year: "numeric" })}`;
    el.grid.className = "calendar-grid month";
    el.grid.innerHTML = days.map((day) => {
      const faded = day.getMonth() !== d.getMonth() ? "faded" : "";
      return `<div class="month-cell ${faded}">${dateCell(day)}</div>`;
    }).join("");
    return;
  }

  const year = d.getFullYear();
  const filtered = visibleEvents();
  el.label.textContent = `${selectedLabel} | ${year}`;
  el.grid.className = "calendar-grid year";
  el.grid.innerHTML = Array.from({ length: 12 }, (_, month) => {
    const first = new Date(year, month, 1);
    const daysInMonth = new Date(year, month + 1, 0).getDate();
    const count = Array.from({ length: daysInMonth }, (_, day) => {
      const date = new Date(year, month, day + 1);
      return filtered.filter((ev) => occursOnDate(ev, date, formatDate(date))).length;
    }).reduce((a, b) => a + b, 0);

    return `
      <article class="cell month-summary">
        <h4>${first.toLocaleDateString(undefined, { month: "long" })}</h4>
        <p>${count} event${count === 1 ? "" : "s"}</p>
      </article>
    `;
  }).join("");
}

function renderRequests() {
  el.requestList.innerHTML = visibleRequests().map((item) => {
    const memberName = displayMemberName(item);
    return `
      <li>
        <div class="list-content">
          <span>${escapeHtml(item.text)}</span>
          <span class="member-pill" style="--member-color: ${memberColor(memberName)}">${escapeHtml(memberName)}</span>
        </div>
        <button class="icon-btn" data-delete-request="${item.id}">✕</button>
      </li>
    `;
  }).join("") || `<li class="muted">No requests</li>`;
}

function isOverdue(item) {
  return !item.done && item.mustDoDate < formatDate(new Date());
}

function renderTodos() {
  const sorted = [...visibleTodos()].sort((a, b) => {
    if (a.done !== b.done) return a.done ? 1 : -1;
    return a.mustDoDate.localeCompare(b.mustDoDate);
  });

  el.todoList.innerHTML = sorted.map((item) => {
    const memberName = displayMemberName(item);
    return `
      <li class="${isOverdue(item) ? "overdue" : ""}">
        <div class="list-content">
          <label>
            <input type="checkbox" data-toggle-todo="${item.id}" ${item.done ? "checked" : ""} />
            <span class="${item.done ? "done" : ""}">${escapeHtml(item.text)}</span>
          </label>
          <div class="todo-meta">
            <small>Must do: ${escapeHtml(item.mustDoDate)}</small>
            <span class="member-pill" style="--member-color: ${memberColor(memberName)}">${escapeHtml(memberName)}</span>
          </div>
        </div>
        <button class="icon-btn" data-delete-todo="${item.id}">✕</button>
      </li>
    `;
  }).join("") || `<li class="muted">No high-priority to-dos</li>`;
}

function renderRecurring() {
  const recurring = visibleEvents().filter((ev) => ev.recurring !== "none");
  el.recurringList.innerHTML = recurring.map((ev) => {
    const memberName = displayMemberName(ev);
    return `
      <li>
        <div class="list-content">
          <span>${escapeHtml(ev.title)} <small>(${escapeHtml(ev.recurring)})</small></span>
          <span class="member-pill" style="--member-color: ${memberColor(memberName)}">${escapeHtml(memberName)}</span>
        </div>
        <button class="icon-btn" data-remove-recurring="${ev.id}" title="Remove recurring activity">✕</button>
      </li>
    `;
  }).join("") || `<li class="muted">No recurring activities</li>`;
}

function renderBusyInputs() {
  el.busyHusband.value = state.busy.husband;
  el.busyWife.value = state.busy.wife;
  el.plannerLocation.value = state.busy.location;
}

function renderPersonTabs() {
  const tabs = [
    `<button class="person-tab ${state.selectedPersonId === "family" ? "active" : ""}" data-person-id="family">Family</button>`,
    ...state.members.map((m) => `<button class="person-tab ${state.selectedPersonId === m.id ? "active" : ""}" data-person-id="${m.id}">${escapeHtml(m.name)}</button>`),
  ];
  el.personTabs.innerHTML = tabs.join("");
}

function renderMemberList() {
  const sorted = [...state.members].sort((a, b) => (a.role === b.role ? a.name.localeCompare(b.name) : a.role.localeCompare(b.role)));
  el.memberList.innerHTML = sorted.map((m) => `
    <li>
      <div class="list-content">
        <strong>${escapeHtml(m.name)}</strong>
        <small>${escapeHtml(m.role)} | age ${m.age} | ${escapeHtml(m.gender)}</small>
      </div>
      <div class="row-actions">
        <button class="btn btn-secondary" data-rename-member="${m.id}">Rename</button>
        <button class="icon-btn" data-delete-member="${m.id}">✕</button>
      </div>
    </li>
  `).join("");
}

function renderChores() {
  const items = visibleChores();
  el.choreList.innerHTML = items.map((chore) => {
    const memberName = displayMemberName(chore);
    return `
      <li>
        <div class="list-content">
          <label>
            <input type="checkbox" data-toggle-chore="${chore.id}" ${chore.done ? "checked" : ""} />
            <span class="${chore.done ? "done" : ""}">${escapeHtml(chore.title)} <small>(${escapeHtml(chore.frequency)})</small></span>
          </label>
          <span class="member-pill" style="--member-color: ${memberColor(memberName)}">${escapeHtml(memberName)}</span>
        </div>
        <button class="icon-btn" data-delete-chore="${chore.id}">✕</button>
      </li>
    `;
  }).join("") || `<li class="muted">No chores for this view.</li>`;
}

function populateMemberSelects() {
  const lists = [el.eventMember, el.requestMember, el.todoMember, el.choreMember, el.icalMember];
  const selectedMember = state.selectedPersonId !== "family" ? state.selectedPersonId : (state.members[0]?.id || "");
  for (const select of lists) {
    if (!select) continue;
    select.innerHTML = state.members.map((m) => `<option value="${m.id}">${escapeHtml(m.name)}</option>`).join("");
    if (selectedMember && findMemberById(selectedMember)) select.value = selectedMember;
  }
}

function updateChoreNote() {
  const selected = findMemberById(state.selectedPersonId);
  el.choreGenNote.textContent = selected
    ? `Generate chores for ${selected.name}.`
    : "Select a person tab to generate chores.";
}

function generatedChoresFor(member) {
  const roleBase = member.role === "adult"
    ? [
        { title: "Unload/load dishwasher", frequency: "Daily" },
        { title: "Kitchen reset before bed", frequency: "Daily" },
        { title: "Laundry cycle", frequency: "Weekly" },
        { title: "Meal planning", frequency: "Weekly" },
      ]
    : member.age <= 7
      ? [
          { title: "Make bed", frequency: "Daily" },
          { title: "Put toys away", frequency: "Daily" },
          { title: "Feed pet (with help)", frequency: "Daily" },
          { title: "Sort laundry", frequency: "Weekly" },
        ]
      : member.age <= 12
        ? [
            { title: "Make bed and tidy room", frequency: "Daily" },
            { title: "Clear dishes", frequency: "Daily" },
            { title: "Take out trash", frequency: "Weekly" },
            { title: "Vacuum one room", frequency: "Weekly" },
          ]
        : [
            { title: "Kitchen cleanup", frequency: "Daily" },
            { title: "Laundry full cycle", frequency: "Weekly" },
            { title: "Bathroom clean", frequency: "Weekly" },
            { title: "Yard/garage help", frequency: "Weekly" },
          ];

  const g = member.gender.toLowerCase();
  let bonus = [{ title: "Organize personal area", frequency: "Weekly" }];
  if (g === "boy" || g === "man") bonus = [{ title: "Check and restock household supplies", frequency: "Weekly" }];
  if (g === "girl" || g === "woman") bonus = [{ title: "Plan one grocery-list section", frequency: "Weekly" }];

  return roleBase.concat(bonus).map((task) => ({
    id: uid(),
    title: task.title,
    frequency: task.frequency,
    done: false,
    autogenerated: true,
    memberId: member.id,
    memberName: member.name,
  }));
}

function addDaysToIso(isoDate, days) {
  const d = new Date(`${isoDate}T00:00:00`);
  d.setDate(d.getDate() + days);
  return formatDate(d);
}

function pad2(n) {
  return String(n).padStart(2, "0");
}

function unfoldIcalLines(text) {
  const raw = text.replace(/\r\n/g, "\n").replace(/\r/g, "\n").split("\n");
  const lines = [];
  for (const line of raw) {
    if ((line.startsWith(" ") || line.startsWith("\t")) && lines.length) {
      lines[lines.length - 1] += line.slice(1);
    } else {
      lines.push(line);
    }
  }
  return lines;
}

function parseIcalDatePart(value) {
  if (!/^\d{8}$/.test(value)) return "";
  return `${value.slice(0, 4)}-${value.slice(4, 6)}-${value.slice(6, 8)}`;
}

function parseIcalDateTimePart(value) {
  const m = value.match(/^(\d{4})(\d{2})(\d{2})T(\d{2})(\d{2})(\d{2})?Z?$/);
  if (!m) return { date: "", time: "" };
  const year = Number(m[1]);
  const month = Number(m[2]) - 1;
  const day = Number(m[3]);
  const hour = Number(m[4]);
  const minute = Number(m[5]);
  const second = Number(m[6] || 0);
  const isUtc = value.endsWith("Z");
  const d = isUtc
    ? new Date(Date.UTC(year, month, day, hour, minute, second))
    : new Date(year, month, day, hour, minute, second);
  return { date: formatDate(d), time: `${pad2(d.getHours())}:${pad2(d.getMinutes())}` };
}

function parseIcalText(text) {
  const lines = unfoldIcalLines(text);
  const events = [];
  let current = null;

  for (const line of lines) {
    if (line === "BEGIN:VEVENT") {
      current = {};
      continue;
    }
    if (line === "END:VEVENT") {
      if (current) events.push(current);
      current = null;
      continue;
    }
    if (!current || !line.includes(":")) continue;

    const idx = line.indexOf(":");
    const left = line.slice(0, idx);
    const value = line.slice(idx + 1);
    const [keyRaw, ...paramParts] = left.split(";");
    const key = keyRaw.toUpperCase();
    const params = paramParts.join(";").toUpperCase();
    current[key] = { value, params };
  }

  return events.map((evt) => {
    const summary = evt.SUMMARY?.value || "Imported Event";
    const dtStart = evt.DTSTART?.value || "";
    const dtEnd = evt.DTEND?.value || "";
    const startIsDate = evt.DTSTART?.params?.includes("VALUE=DATE");
    const endIsDate = evt.DTEND?.params?.includes("VALUE=DATE");
    const rrule = evt.RRULE?.value || "";

    let startDate = "";
    let endDate = "";
    let startTime = "";
    let endTime = "";

    if (startIsDate || /^\d{8}$/.test(dtStart)) {
      startDate = parseIcalDatePart(dtStart);
      endDate = dtEnd ? parseIcalDatePart(dtEnd) : startDate;
      if (dtEnd && (endIsDate || /^\d{8}$/.test(dtEnd))) {
        endDate = addDaysToIso(endDate, -1);
      }
    } else {
      const start = parseIcalDateTimePart(dtStart);
      const end = dtEnd ? parseIcalDateTimePart(dtEnd) : start;
      startDate = start.date;
      endDate = end.date || start.date;
      startTime = start.time;
      endTime = end.time;
    }

    let recurring = "none";
    const freq = rrule.match(/FREQ=([A-Z]+)/)?.[1] || "";
    if (freq === "DAILY") recurring = "daily";
    if (freq === "WEEKLY") recurring = "weekly";
    if (freq === "MONTHLY") recurring = "monthly";

    return {
      title: summary,
      startDate,
      endDate: endDate || startDate,
      start: startTime,
      end: endTime,
      recurring,
    };
  }).filter((ev) => ev.startDate);
}

function escapeIcalText(text) {
  return String(text || "")
    .replace(/\\/g, "\\\\")
    .replace(/\n/g, "\\n")
    .replace(/,/g, "\\,")
    .replace(/;/g, "\\;");
}

function toIcalDate(isoDate) {
  return isoDate.replace(/-/g, "");
}

function toIcalDateTime(isoDate, time) {
  const hh = (time || "00:00").slice(0, 2);
  const mm = (time || "00:00").slice(3, 5);
  return `${toIcalDate(isoDate)}T${hh}${mm}00`;
}

function exportIcalText(rows) {
  const now = new Date();
  const stamp = `${now.getUTCFullYear()}${pad2(now.getUTCMonth() + 1)}${pad2(now.getUTCDate())}T${pad2(now.getUTCHours())}${pad2(now.getUTCMinutes())}${pad2(now.getUTCSeconds())}Z`;
  const lines = [
    "BEGIN:VCALENDAR",
    "VERSION:2.0",
    "PRODID:-//Family Calendar//EN",
    "CALSCALE:GREGORIAN",
  ];

  for (const ev of rows) {
    const memberName = displayMemberName(ev);
    const summary = `${ev.title} (${memberName})`;
    lines.push("BEGIN:VEVENT");
    lines.push(`UID:${ev.id}@familycalendar.local`);
    lines.push(`DTSTAMP:${stamp}`);
    if (ev.start || ev.end) {
      const dtStart = toIcalDateTime(ev.startDate, ev.start || "09:00");
      const dtEnd = toIcalDateTime(ev.endDate || ev.startDate, ev.end || ev.start || "10:00");
      lines.push(`DTSTART:${dtStart}`);
      lines.push(`DTEND:${dtEnd}`);
    } else {
      lines.push(`DTSTART;VALUE=DATE:${toIcalDate(ev.startDate)}`);
      lines.push(`DTEND;VALUE=DATE:${toIcalDate(addDaysToIso(ev.endDate || ev.startDate, 1))}`);
    }
    if (ev.recurring === "daily") lines.push("RRULE:FREQ=DAILY");
    if (ev.recurring === "weekly") lines.push("RRULE:FREQ=WEEKLY");
    if (ev.recurring === "monthly") lines.push("RRULE:FREQ=MONTHLY");
    lines.push(`SUMMARY:${escapeIcalText(summary)}`);
    lines.push("END:VEVENT");
  }

  lines.push("END:VCALENDAR");
  return lines.join("\\r\\n");
}

function parseBusyBlocks(text) {
  const blocks = [];
  const parts = text.split(",").map((v) => v.trim()).filter(Boolean);
  for (const part of parts) {
    const m = part.match(/^(sun|mon|tue|wed|thu|fri|sat)\s+(\d{1,2}):(\d{2})-(\d{1,2}):(\d{2})$/i);
    if (!m) continue;
    const day = DAY_INDEX[m[1].toLowerCase()];
    const start = Number(m[2]) * 60 + Number(m[3]);
    const end = Number(m[4]) * 60 + Number(m[5]);
    if (Number.isFinite(day) && start < end) blocks.push({ day, start, end });
  }
  return blocks;
}

function parseTimeToMinutes(value) {
  if (!value || !value.includes(":")) return null;
  const [h, m] = value.split(":").map(Number);
  if (!Number.isFinite(h) || !Number.isFinite(m)) return null;
  return h * 60 + m;
}

function overlaps(startA, endA, startB, endB) {
  return !(endA <= startB || startA >= endB);
}

function eventBlocksForDate(dateObj) {
  return state.events
    .filter((ev) => occursOnDate(ev, dateObj, formatDate(dateObj)))
    .map((ev) => {
      const s = parseTimeToMinutes(ev.start);
      const e = parseTimeToMinutes(ev.end);
      if (s === null && e === null) return { start: 0, end: 24 * 60 };
      if (s !== null && e === null) return { start: s, end: Math.min(s + 90, 24 * 60) };
      if (s === null && e !== null) return { start: 0, end: e };
      return { start: s, end: e > s ? e : 24 * 60 };
    });
}

function scanBestDateSlots() {
  const busyHusband = parseBusyBlocks(state.busy.husband);
  const busyWife = parseBusyBlocks(state.busy.wife);
  const now = new Date();
  now.setHours(0, 0, 0, 0);
  const candidates = [];

  for (let i = 0; i < 28; i += 1) {
    const day = new Date(now);
    day.setDate(now.getDate() + i);
    const weekday = day.getDay();
    const dayBusy = busyHusband.concat(busyWife)
      .filter((b) => b.day === weekday)
      .map((b) => ({ start: b.start, end: b.end }));
    const blocked = dayBusy.concat(eventBlocksForDate(day));

    for (const slot of SLOT_TEMPLATES) {
      if (blocked.some((b) => overlaps(b.start, b.end, slot.start, slot.end))) continue;
      let score = slot.weight;
      if (weekday === 5 || weekday === 6) score += 3;
      if (weekday === 4) score += 2;
      score -= i * 0.03;
      candidates.push({ date: new Date(day), slot, score });
    }
  }

  return candidates.sort((a, b) => b.score - a.score).slice(0, 6);
}

function placeName(displayName) {
  return displayName.split(",")[0] || displayName;
}

function mapLink(lat, lon) {
  return `https://www.openstreetmap.org/?mlat=${lat}&mlon=${lon}#map=16/${lat}/${lon}`;
}

async function fetchLocalIdeas(location) {
  const loc = location.trim();
  if (!loc) return { error: "Add a city and state to fetch local ideas." };

  const fetchJson = async (url) => {
    const resp = await fetch(url);
    if (!resp.ok) throw new Error("Failed");
    return resp.json();
  };

  try {
    const restaurantUrl = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=6&q=${encodeURIComponent(`restaurants in ${loc}`)}`;
    const venueUrl = `https://nominatim.openstreetmap.org/search?format=json&addressdetails=1&limit=6&q=${encodeURIComponent(`things to do in ${loc}`)}`;
    const [restaurantsRaw, venuesRaw] = await Promise.all([fetchJson(restaurantUrl), fetchJson(venueUrl)]);

    const seen = new Set();
    const uniq = (rows, type) => rows
      .map((row) => ({ type, name: placeName(row.display_name || "Unknown"), link: mapLink(row.lat, row.lon) }))
      .filter((p) => {
        const k = p.name.toLowerCase();
        if (seen.has(k)) return false;
        seen.add(k);
        return true;
      })
      .slice(0, 4);

    return { restaurants: uniq(restaurantsRaw, "Restaurant"), venues: uniq(venuesRaw, "Venue") };
  } catch (_err) {
    return { error: "Could not fetch local places right now." };
  }
}

async function suggestDates() {
  state.busy.husband = el.busyHusband.value.trim();
  state.busy.wife = el.busyWife.value.trim();
  state.busy.location = el.plannerLocation.value.trim();

  const bestSlots = scanBestDateSlots();
  el.plannerOutput.innerHTML = bestSlots.length
    ? bestSlots.map((item) => {
      const startH = String(Math.floor(item.slot.start / 60)).padStart(2, "0");
      const startM = String(item.slot.start % 60).padStart(2, "0");
      const endH = String(Math.floor(item.slot.end / 60)).padStart(2, "0");
      const endM = String(item.slot.end % 60).padStart(2, "0");
      return `<li><strong>${escapeHtml(item.slot.label)}</strong> | ${item.date.toLocaleDateString(undefined, { weekday: "long", month: "short", day: "numeric" })} | ${startH}:${startM}-${endH}:${endM}</li>`;
    }).join("")
    : "<li>No open date windows found in next 4 weeks.</li>";

  el.plannerPlaces.innerHTML = "<li>Loading local ideas...</li>";
  const places = await fetchLocalIdeas(state.busy.location);
  if (places.error) {
    el.plannerPlaces.innerHTML = `<li>${escapeHtml(places.error)}</li>`;
    await saveState();
    return;
  }

  const rows = [];
  for (const p of places.restaurants || []) {
    rows.push(`<li><div class="list-content"><span><strong>${escapeHtml(p.name)}</strong><br><small>${escapeHtml(p.type)}</small></span><a href="${p.link}" target="_blank" rel="noreferrer">Map</a></div></li>`);
  }
  for (const p of places.venues || []) {
    rows.push(`<li><div class="list-content"><span><strong>${escapeHtml(p.name)}</strong><br><small>${escapeHtml(p.type)}</small></span><a href="${p.link}" target="_blank" rel="noreferrer">Map</a></div></li>`);
  }
  el.plannerPlaces.innerHTML = rows.join("") || "<li>No places found.</li>";
  await saveState();
}

function escapeHtml(str) {
  return String(str)
    .replace(/&/g, "&amp;")
    .replace(/</g, "&lt;")
    .replace(/>/g, "&gt;")
    .replace(/\"/g, "&quot;")
    .replace(/'/g, "&#039;");
}

function memberFromSelect(selectEl) {
  const member = findMemberById(selectEl.value);
  return member || state.members[0] || null;
}

document.getElementById("eventForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const title = document.getElementById("eventTitle").value.trim();
  const startDate = document.getElementById("eventStartDate").value;
  const endRaw = document.getElementById("eventEndDate").value;
  const member = memberFromSelect(el.eventMember);
  if (!title || !startDate || !endRaw || !member) return;

  state.events.push({
    id: uid(),
    title,
    startDate,
    endDate: endRaw < startDate ? startDate : endRaw,
    start: document.getElementById("eventStart").value,
    end: document.getElementById("eventEnd").value,
    memberId: member.id,
    memberName: member.name,
    recurring: document.getElementById("eventRecurring").value,
  });

  e.target.reset();
  populateMemberSelects();
  await saveState();
  renderCalendar();
  renderRecurring();
});

document.getElementById("requestForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = document.getElementById("requestInput").value.trim();
  const member = memberFromSelect(el.requestMember);
  if (!text || !member) return;
  state.requests.unshift({ id: uid(), text, memberId: member.id, memberName: member.name });
  e.target.reset();
  populateMemberSelects();
  await saveState();
  renderRequests();
});

document.getElementById("todoForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const text = document.getElementById("todoInput").value.trim();
  const mustDoDate = document.getElementById("todoMustDoDate").value;
  const member = memberFromSelect(el.todoMember);
  if (!text || !mustDoDate || !member) return;
  state.todos.unshift({ id: uid(), text, mustDoDate, done: false, memberId: member.id, memberName: member.name });
  e.target.reset();
  populateMemberSelects();
  await saveState();
  renderTodos();
});

document.getElementById("memberForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const name = document.getElementById("memberName").value.trim();
  const role = document.getElementById("memberRole").value;
  const age = Number(document.getElementById("memberAge").value);
  const gender = document.getElementById("memberGender").value;
  if (!name || !role || !age || !gender) return;

  state.members.push({ id: uid(), name, role, age, gender });
  e.target.reset();
  await saveState();
  renderPersonTabs();
  populateMemberSelects();
  renderMemberList();
  updateChoreNote();
});

document.getElementById("choreForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const title = document.getElementById("choreInput").value.trim();
  const frequency = document.getElementById("choreFrequency").value;
  const member = memberFromSelect(el.choreMember);
  if (!title || !member) return;

  state.chores.unshift({
    id: uid(),
    title,
    frequency,
    done: false,
    autogenerated: false,
    memberId: member.id,
    memberName: member.name,
  });
  e.target.reset();
  populateMemberSelects();
  await saveState();
  renderChores();
});

document.getElementById("generateChoresBtn").addEventListener("click", async () => {
  const member = findMemberById(state.selectedPersonId);
  if (!member) {
    alert("Select a specific person tab first.");
    return;
  }

  state.chores = state.chores.filter((c) => !(c.memberId === member.id && c.autogenerated));
  state.chores.unshift(...generatedChoresFor(member));
  await saveState();
  renderChores();
});

document.getElementById("icalForm").addEventListener("submit", async (e) => {
  e.preventDefault();
  const fileInput = document.getElementById("icalFile");
  const file = fileInput.files && fileInput.files[0];
  const member = memberFromSelect(el.icalMember);
  if (!file || !member) return;

  const text = await file.text();
  const incoming = parseIcalText(text);
  let merged = 0;

  for (const ev of incoming) {
    const duplicate = state.events.some((existing) =>
      existing.title === ev.title &&
      existing.startDate === ev.startDate &&
      (existing.start || "") === (ev.start || "") &&
      existing.memberId === member.id
    );
    if (duplicate) continue;

    state.events.push({
      id: uid(),
      title: ev.title,
      startDate: ev.startDate,
      endDate: ev.endDate || ev.startDate,
      start: ev.start || "",
      end: ev.end || "",
      memberId: member.id,
      memberName: member.name,
      recurring: ev.recurring || "none",
    });
    merged += 1;
  }

  await saveState();
  renderCalendar();
  renderRecurring();
  fileInput.value = "";
  alert(`Merged ${merged} event${merged === 1 ? "" : "s"} from iCal.`);
});

document.getElementById("exportIcalBtn").addEventListener("click", () => {
  const rows = visibleEvents();
  const text = exportIcalText(rows);
  const blob = new Blob([text], { type: "text/calendar;charset=utf-8" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url;
  a.download = `family-calendar-${formatDate(new Date())}.ics`;
  document.body.appendChild(a);
  a.click();
  a.remove();
  URL.revokeObjectURL(url);
});

el.requestList.addEventListener("click", async (e) => {
  const id = e.target.dataset.deleteRequest;
  if (!id) return;
  state.requests = state.requests.filter((r) => r.id !== id);
  await saveState();
  renderRequests();
});

el.todoList.addEventListener("click", async (e) => {
  const id = e.target.dataset.deleteTodo;
  if (!id) return;
  state.todos = state.todos.filter((t) => t.id !== id);
  await saveState();
  renderTodos();
});

el.todoList.addEventListener("change", async (e) => {
  const id = e.target.dataset.toggleTodo;
  if (!id) return;
  const row = state.todos.find((t) => t.id === id);
  if (!row) return;
  row.done = !!e.target.checked;
  await saveState();
  renderTodos();
});

el.recurringList.addEventListener("click", async (e) => {
  const id = e.target.dataset.removeRecurring;
  if (!id) return;
  state.events = state.events.filter((ev) => ev.id !== id);
  await saveState();
  renderCalendar();
  renderRecurring();
});

el.memberList.addEventListener("click", async (e) => {
  const renameId = e.target.dataset.renameMember;
  if (renameId) {
    const member = findMemberById(renameId);
    if (!member) return;
    const next = prompt("New name:", member.name);
    if (!next || !next.trim()) return;
    member.name = next.trim();

    for (const set of [state.events, state.requests, state.todos, state.chores]) {
      for (const item of set) {
        if (item.memberId === member.id) item.memberName = member.name;
      }
    }

    await saveState();
    renderPersonTabs();
    populateMemberSelects();
    renderMemberList();
    renderCalendar();
    renderRequests();
    renderTodos();
    renderRecurring();
    renderChores();
    return;
  }

  const deleteId = e.target.dataset.deleteMember;
  if (!deleteId) return;
  if (state.members.length <= 1) {
    alert("Keep at least one member.");
    return;
  }

  state.members = state.members.filter((m) => m.id !== deleteId);
  state.events = state.events.filter((x) => x.memberId !== deleteId);
  state.requests = state.requests.filter((x) => x.memberId !== deleteId);
  state.todos = state.todos.filter((x) => x.memberId !== deleteId);
  state.chores = state.chores.filter((x) => x.memberId !== deleteId);

  if (state.selectedPersonId === deleteId) state.selectedPersonId = "family";

  await saveState();
  render();
});

el.choreList.addEventListener("click", async (e) => {
  const id = e.target.dataset.deleteChore;
  if (!id) return;
  state.chores = state.chores.filter((c) => c.id !== id);
  await saveState();
  renderChores();
});

el.choreList.addEventListener("change", async (e) => {
  const id = e.target.dataset.toggleChore;
  if (!id) return;
  const item = state.chores.find((c) => c.id === id);
  if (!item) return;
  item.done = !!e.target.checked;
  await saveState();
  renderChores();
});

el.grid.addEventListener("click", (e) => {
  const action = e.target.dataset.action;
  if (action !== "jump") return;
  const date = e.target.dataset.date;
  if (!date) return;
  document.getElementById("eventStartDate").value = date;
  document.getElementById("eventEndDate").value = date;
  document.getElementById("eventTitle").focus();
});

el.grid.addEventListener("change", async (e) => {
  const choreId = e.target.dataset.toggleChore;
  if (!choreId) return;
  const item = state.chores.find((c) => c.id === choreId);
  if (!item) return;
  item.done = !!e.target.checked;
  await saveState();
  renderCalendar();
  renderChores();
});

el.personTabs.addEventListener("click", (e) => {
  const id = e.target.dataset.personId;
  if (!id) return;
  setSelectedPerson(id);
});

el.topTabs.forEach((btn) => {
  btn.addEventListener("click", () => setActiveTab(btn.dataset.tab));
});

document.getElementById("planDateBtn").addEventListener("click", suggestDates);
document.getElementById("prevBtn").addEventListener("click", () => shiftDate(-1));
document.getElementById("nextBtn").addEventListener("click", () => shiftDate(1));
document.getElementById("todayBtn").addEventListener("click", () => {
  state.currentDate = new Date();
  renderCalendar();
});

document.getElementById("shareBtn").addEventListener("click", async () => {
  if (!state.roomId) {
    state.roomId = roomId();
    const url = new URL(window.location.href);
    url.searchParams.set("room", state.roomId);
    url.searchParams.delete("data");
    window.history.replaceState({}, "", url.toString());
    await saveState();
    startSyncPolling();
  }

  const link = `${window.location.origin}${window.location.pathname}?room=${encodeURIComponent(state.roomId)}`;
  try {
    await navigator.clipboard.writeText(link);
    alert("Live share link copied. Anyone with this link can view and update this family calendar.");
  } catch (_err) {
    prompt("Copy this live share link:", link);
  }
});

el.viewBtns.forEach((btn) => {
  btn.addEventListener("click", () => setView(btn.dataset.view));
});

function render() {
  setActiveTab(state.activeTab, false);
  renderPersonTabs();
  populateMemberSelects();
  renderCalendar();
  renderRequests();
  renderTodos();
  renderRecurring();
  renderBusyInputs();
  renderMemberList();
  renderChores();
  updateChoreNote();
}

(async () => {
  await loadState();
  render();
})();
